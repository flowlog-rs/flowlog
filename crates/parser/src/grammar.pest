// =============================================================================
// FlowLog GRAMMAR DEFINITION
// =============================================================================
// This grammar defines the syntax for FlowLog, a Datalog language engine
// for declarative data processing and rule-based queries.

// Main grammar entry point
main_grammar = { 
    SOI ~ 
    (declaration | input_directive | output_directive | printsize_directive | rule)* ~
    EOI
} 

// =============================================================================
// BASIC ELEMENTS (IDENTIFIERS, LITERALS, TYPES)
// =============================================================================

// Identifier pattern - must start with letter or underscore, 
// can contain letters, numbers, underscores
// Valid examples: x, _temp, myVar123, _private_var
// Invalid examples: 1x, x-yz (hyphen not allowed)
identifier = @{ "_"? ~ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_")* }

// Variable reference - variables used in rules and queries
variable = { identifier }

// Attribute name - names of relation attributes (columns)
attribute_name = { identifier }

// Relation name - names of relations (tables)
relation_name = { identifier }

// Data type specification
data_type = { integer64_type | integer32_type | string_type }

// 32-bit integer data type
integer32_type = { "int32" }

// 64-bit integer data type
integer64_type = { "int64" }

// Text data type for strings
string_type = { "string" }

// Constant values
constant = { integer | string } 

// Integer with optional sign
// Examples: 42, -17, +100
integer = @{ ("+" | "-")? ~ ASCII_DIGIT+ }

// String enclosed in double quotes
// Example: "hello world"
string = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Placeholder for unused variables (underscore)
// Used when you don't need to reference a variable
placeholder = { "_" } 

// Boolean values used in expressions
boolean = { "True" | "False" } 

// =============================================================================
// RELATION DECLARATIONS
// =============================================================================
// Relations are the core data structures in FlowLog. They can be:
// - EDB (Extensional Database): Input relations with external data
// - IDB (Intentional Database): Computed relations defined by rules

// Declaration only defines the relation schema
// I/O directives are separate and can appear anywhere in the program
declaration = { 
    ".decl" ~ relation_name ~ "(" ~ attributes_decl? ~ ")"
}

// Input directive for EDB relations - separate from declaration
// Example: .input Relation(IO="file", filename="data.csv", delimiter=",")
input_directive = { 
    ".input" ~ relation_name ~ "(" ~ input_params? ~ ")"
}

// Input parameters
input_params = { input_param ~ ("," ~ input_param)* }

// Individual input parameter
input_param = { parameter_name ~ "=" ~ parameter_value }

// Parameter name (IO, filename, delimiter, etc.)
parameter_name = { identifier }

// Parameter value (quoted string)
parameter_value = { string }

// Output directive for relations
// Example: .output Relation
output_directive = { 
    ".output" ~ relation_name
}

// Print size directive for relations - separate from declaration
// Example: .printsize Relation
printsize_directive = {
    ".printsize" ~ relation_name
}

// Comma-separated list of attribute declarations
// Example: src: number, dst: number, weight: string
attributes_decl = { attribute_decl ~ ("," ~ attribute_decl)* }

// Single attribute with name and data type
// Example: "src: number" 
attribute_decl = { attribute_name ~ ":" ~ data_type }

// =============================================================================
// ARITHMETIC EXPRESSIONS
// =============================================================================
// Mathematical expressions with basic operators

// Simple arithmetic without precedence
// Note: "x + y * z" is parsed left-to-right as "(x + y) * z"
arithmetic_expr = { factor ~ (arithmetic_op ~ factor)* }

// Basic elements in arithmetic expressions
factor = { variable | constant }

// Arithmetic operators
arithmetic_op = { 
    plus |    // +
    minus |   // -
    times |   // *
    divide |  // /
    modulo    // %
}

// Individual arithmetic operators
plus = { "+" }
minus = { "-" }
times = { "*" }
divide = { "/" }
modulo = { "%" }

// =============================================================================
// COMPARISON EXPRESSIONS  
// =============================================================================
// Binary comparisons between arithmetic expressions

// Binary comparison between arithmetic expressions
// Examples: x + y > z + w, count(x) = 5
compare_expr = { arithmetic_expr ~ compare_op ~ arithmetic_expr }

// Comparison operators
compare_op = { 
    equal |               // =
    not_equal |           // !=
    greater_equal_than |  // >=
    greater_than |        // >
    less_equal_than |     // <=
    less_than             // <
}

// Individual comparison operators
equal = { "=" } 
not_equal = { "!=" }
greater_equal_than = { ">=" }
greater_than = { ">" }
less_equal_than = { "<=" }
less_than = { "<" }

// =============================================================================
// AGGREGATE EXPRESSIONS
// =============================================================================
// Aggregation functions for computing statistics over groups

// Aggregation operation on a value
// Examples: count(x), avg(x + y), sum(weight)
aggregate_expr = { 
    aggregate_op ~ 
    "(" ~ 
    arithmetic_expr ~
    ")" 
} 

// Supported aggregate operators
aggregate_op = { count | average | sum | min | max }
count = { "count" | "COUNT" }       // Count of elements
average = { "average" | "AVG" }     // Average value
sum = { "sum" | "SUM" }             // Sum of values
min = { "min" | "MIN" }             // Minimum value
max = { "max" | "MAX" }             // Maximum value

// =============================================================================
// ATOMS (RELATION REFERENCES)
// =============================================================================
// Atoms represent relation instances with specific arguments

// Relation with arguments
// Example: edge(x, y), person("Alice", 25)
atom = { 
    relation_name ~ 
    "(" ~ 
    (atom_arg ~ ("," ~ atom_arg)*)? ~ 
    ")" 
}

// Negative atom for negative conditions
// Example: !edge(x, y)
negative_atom = { "!" ~ atom }

// Arguments in atoms can be variables, constants, or placeholders
atom_arg = { variable | constant | placeholder } 

// =============================================================================
// RULES SECTION
// =============================================================================
// Rules define how output relations are computed from input relations
// Format: head :- body.
// Example: reachable(x, z) :- edge(x, y), reachable(y, z).

// Single rule with head, body predicates, and optional optimization directive
// Format: head :- predicate1, predicate2, ... .
rule = { head ~ ":-" ~ predicates ~ "." ~ optimize? }

// Left side of rule (before :-)
// Example: reachable(x, z), stats(count(x))
head = {
    relation_name ~ 
    "(" ~ 
    (head_arg ~ ("," ~ head_arg)*)? ~
    ")" 
}

// Can be aggregate functions or arithmetic expressions
head_arg = { aggregate_expr | arithmetic_expr }

// Comma-separated list of predicates in the rule body
predicates = { predicate ~ ("," ~ predicate)* }

// Types of predicates allowed in rule bodies
predicate = { 
    atom |          // Positive atom: edge(x, y)
    negative_atom | // Negative atom: !edge(x, y)  
    compare_expr |  // Comparison: x > y
    boolean         // Boolean atom: True/False
}

// Optimization hint directives for query planning
optimize = { ".plan" }

// =============================================================================
// WHITESPACE AND COMMENTS
// =============================================================================
// Rules for handling whitespace and comments (ignored during parsing)

// Whitespace and comments are ignored during parsing
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Comment starts with # or // and continues until end of line
// Examples: # This is a comment, // Another comment
COMMENT = _{ ("#" | "//") ~ (!NEWLINE ~ ANY)* }