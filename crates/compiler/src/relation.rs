use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::parse2;

use parser::{DataType, Relation};

use super::Compiler;

impl Compiler {
    /// Render `src/relops.rs` for incremental mode.
    ///
    /// - Nullary relations handled by a dedicated generator (no parsing; worker0 only).
    /// - Non-nullary relations:
    ///   - No panics: parse/open errors print to stderr and skip.
    ///   - Shard by first column (int mod peers; string FNV-1a).
    ///   - Delimiter is `rel.input_delimiter()` (1 byte, default comma).
    pub(crate) fn render_relops(&self, edbs: Vec<&Relation>) -> String {
        let rel_impls: Vec<TokenStream> = edbs
            .iter()
            .map(|rel| {
                if rel.arity() == 0 {
                    gen_one_rel_nullary(rel)
                } else {
                    gen_one_rel_nonnullary(rel)
                }
            })
            .collect();

        let file = quote! {
            //! Dynamic relation handlers for incremental input sessions.
            //!
            //! This module is generated by the FlowLog compiler. It defines a uniform interface
            //! (`RelOps`) over per-relation input handlers backed by
            //! [`differential_dataflow::input::InputSession`].
            //!
            //! Each generated handler supports:
            //! - Applying a single tuple update (`apply_tuple`)
            //! - Applying updates from a delimited file (`apply_file`)
            //! - Advancing / flushing / closing the underlying input session
            //!
            //! Sharding:
            //! - For non-nullary relations, updates are sharded by the *first* column.
            //! - Integer keys shard by `key % peers`.
            //! - String keys shard by 32-bit FNV-1a.
            //!
            //! Nullary relations:
            //! - Are handled by a dedicated generator (no parsing).
            //! - Only worker 0 applies updates to avoid multiplying diffs across workers.
            //! - File ingestion is intentionally unsupported (tuple interaction only).

            use differential_dataflow::input::InputSession;

            use std::fs::File;
            use std::io::{BufRead, BufReader};
            use std::path::Path;

            /// Diff type used by incremental input sessions.
            type Diff = i32;

            /// Operations supported by a dynamic relation handler.
            ///
            /// Implementations are generated per EDB relation and backed by an
            /// [`InputSession`]. Implementations are expected to be robust:
            /// parsing and I/O errors should be reported to stderr and skipped.
            pub(crate) trait RelOps {
                /// Apply a single tuple update.
                ///
                /// `tuple` is a delimited string whose delimiter is relation-specific.
                /// Implementations should shard by the first column and apply the update
                /// only on the matching worker.
                fn apply_tuple(&mut self, tuple: &str, diff: Diff, peers: usize, index: usize);

                /// Apply updates from a file.
                ///
                /// Implementations should read line-by-line, parse columns, shard by the first
                /// column, and apply `diff` to each parsed tuple.
                fn apply_file(&mut self, path: &Path, diff: Diff, peers: usize, index: usize);

                /// Advance the input session to logical time `t`.
                fn advance_to(&mut self, t: u32);

                /// Flush buffered updates into the dataflow.
                fn flush(&mut self);

                /// Close the input session.
                fn close(&mut self);
            }

            /// Shard on an `i32` first column by `first % peers`.
            #[allow(dead_code)]
            #[inline]
            fn shard_i32(first: i32, peers: usize, index: usize) -> bool {
                (first as usize) % peers == index
            }

            /// Shard on an `i64` first column by `first % peers`.
            #[allow(dead_code)]
            #[inline]
            fn shard_i64(first: i64, peers: usize, index: usize) -> bool {
                (first as usize) % peers == index
            }

            /// Shard on a string first column using 32-bit FNV-1a.
            #[allow(dead_code)]
            #[inline]
            fn shard_str(first: &str, peers: usize, index: usize) -> bool {
                // 32-bit FNV-1a
                let mut hash: u32 = 0x811c9dc5;
                for &b in first.as_bytes() {
                    hash ^= b as u32;
                    hash = hash.wrapping_mul(0x01000193);
                }
                (hash as usize) % peers == index
            }

            #(#rel_impls)*
        };

        let syntax = parse2(file).unwrap();
        prettyplease::unparse(&syntax)
    }
}

// ------------------------------------------------------------
// Per-relation generators
// ------------------------------------------------------------

fn gen_one_rel_nullary(rel: &Relation) -> TokenStream {
    let name = rel.name();
    let struct_name = format_ident!("Rel{}", name);

    quote! {
        /// Input handler for the nullary relation.
        ///
        /// Nullary relations store a single boolean-like fact (`True`/`False`) and are
        /// updated only by worker 0 to avoid multiplying diffs across workers.
        pub(crate) struct #struct_name {
            h: Option<InputSession<u32, (), Diff>>,
        }

        impl #struct_name {
            /// Create a new nullary handler.
            pub fn new(h: InputSession<u32, (), Diff>) -> Self {
                Self { h: Some(h) }
            }

            /// Borrow the underlying input session.
            #[inline]
            fn h_mut(&mut self) -> &mut InputSession<u32, (), Diff> {
                self.h.as_mut().unwrap()
            }
        }

        impl RelOps for #struct_name {
            fn apply_tuple(&mut self, tuple: &str, _diff: Diff, _peers: usize, index: usize) {
                // Nullary: only worker0 applies (avoid multiplying diffs across workers).
                if index != 0 { return; }

                let s = tuple.trim();
                let d: Diff = if s.eq_ignore_ascii_case("true") {
                    1
                } else if s.eq_ignore_ascii_case("false") {
                    -1
                } else {
                    eprintln!(
                        "[relops][{}] nullary expects tuple 'True' or 'False', got {:?}",
                        #name,
                        s
                    );
                    return;
                };

                self.h_mut().update((), d);
            }

            fn apply_file(&mut self, path: &Path, _diff: Diff, _peers: usize, index: usize) {
                if index != 0 { return; }

                // Per request: nullary relations only allow tuple interaction.
                eprintln!(
                    "[relops][{}] nullary relation does not support file ingestion. Use: put {} True|False",
                    #name,
                    path.display()
                );
            }

            fn advance_to(&mut self, t: u32) {
                self.h_mut().advance_to(t);
            }

            fn flush(&mut self) {
                self.h_mut().flush();
            }

            fn close(&mut self) {
                if let Some(h) = self.h.take() {
                    h.close();
                }
            }
        }
    }
}

fn gen_one_rel_nonnullary(rel: &Relation) -> TokenStream {
    let name = rel.name();
    let struct_name = format_ident!("Rel{}", name);

    let arity = rel.arity();
    debug_assert!(arity > 0);

    let dts = rel.data_type();

    let delim_byte: u8 = rel
        .input_delimiter()
        .as_bytes()
        .first()
        .copied()
        .unwrap_or(b',');

    // tuple type: (T0,), (T0,T1,...)
    let rust_tys: Vec<TokenStream> = dts.iter().map(dt_to_rust).collect();
    let tuple_ty: TokenStream = match arity {
        1 => {
            let t0 = &rust_tys[0];
            quote! { (#t0,) }
        }
        _ => quote! { (#(#rust_tys),*) },
    };

    // shard decision (tuple path uses `return;`, file path uses `return None;`)
    let shard_tuple = match dts[0] {
        DataType::Int32 => quote! { if !shard_i32(f0, peers, index) { return; } },
        DataType::Int64 => quote! { if !shard_i64(f0, peers, index) { return; } },
        DataType::String => quote! { if !shard_str(f0.as_str(), peers, index) { return; } },
    };
    let shard_file = match dts[0] {
        DataType::Int32 => quote! { if !shard_i32(f0, peers, index) { return None; } },
        DataType::Int64 => quote! { if !shard_i64(f0, peers, index) { return None; } },
        DataType::String => quote! { if !shard_str(f0.as_str(), peers, index) { return None; } },
    };

    let tuple_parse_stmts = gen_parse_from_str(name, &dts);
    let file_parse_stmts = gen_parse_from_bytes(name, &dts);

    let update_expr = match arity {
        1 => quote! { (f0,) },
        _ => {
            let vars: Vec<_> = (0..arity).map(|i| format_ident!("f{i}")).collect();
            quote! { (#(#vars),*) }
        }
    };

    quote! {
        /// Input handler for the relation.
        ///
        /// - Parses tuples using the relation delimiter.
        /// - Shards updates by the first column across `peers`.
        /// - Reports parse / I/O errors to stderr and skips malformed rows.
        pub(crate) struct #struct_name {
            h: Option<InputSession<u32, #tuple_ty, Diff>>,
            /// Delimiter byte used for parsing tuple strings / file rows.
            delim: u8,
        }

        impl #struct_name {
            /// Create a new handler.
            pub fn new(h: InputSession<u32, #tuple_ty, Diff>) -> Self {
                Self { h: Some(h), delim: #delim_byte }
            }

            /// Borrow the underlying input session.
            #[inline]
            fn h_mut(&mut self) -> &mut InputSession<u32, #tuple_ty, Diff> {
                self.h.as_mut().unwrap()
            }
        }

        impl RelOps for #struct_name {
            fn apply_tuple(&mut self, tuple: &str, diff: Diff, peers: usize, index: usize) {
                let tuple = tuple.trim();
                let delim = self.delim as char;
                let mut it = tuple.split(delim).map(|s| s.trim());

                #tuple_parse_stmts

                #shard_tuple
                self.h_mut().update(#update_expr, diff);
            }

            fn apply_file(&mut self, path: &Path, diff: Diff, peers: usize, index: usize) {
                let f = match File::open(path) {
                    Ok(f) => f,
                    Err(e) => {
                        eprintln!("[relops][{}] failed to open {}: {}", #name, path.display(), e);
                        return;
                    }
                };
                let reader = BufReader::new(f);
                let delim = self.delim;

                // optimized: build ingest iterator, then apply updates
                let ingest = reader
                    .split(b'\n')
                    .filter_map(Result::ok)
                    .filter(|line| !line.is_empty())
                    .filter_map(|line| {
                        let mut cols = line.split(|&b| b == delim);

                        #file_parse_stmts

                        #shard_file
                        Some(#update_expr)
                    });

                for row in ingest {
                    self.h_mut().update(row, diff);
                }
            }

            fn advance_to(&mut self, t: u32) {
                self.h_mut().advance_to(t);
            }

            fn flush(&mut self) {
                self.h_mut().flush();
            }

            fn close(&mut self) {
                if let Some(h) = self.h.take() {
                    h.close();
                }
            }
        }
    }
}

// ------------------------------------------------------------
// Type + parsing helpers (codegen helpers)
// ------------------------------------------------------------

fn dt_to_rust(dt: &DataType) -> TokenStream {
    match *dt {
        DataType::Int32 => quote! { i32 },
        DataType::Int64 => quote! { i64 },
        DataType::String => quote! { String },
    }
}

/// Parse from `it: Iterator<Item=&str>` into f0..f{n-1}.
/// On error: eprintln + return;
fn gen_parse_from_str(rel: &str, dts: &[DataType]) -> TokenStream {
    let mut stmts = Vec::<TokenStream>::new();

    for (i, dt) in dts.iter().enumerate() {
        let v = format_ident!("f{i}");
        let idx = i;

        let get = quote! {
            let s = match it.next() {
                Some(s) => s,
                None => {
                    eprintln!("[relops][{}] bad tuple '{}': missing col {}", #rel, tuple, #idx);
                    return;
                }
            };
        };

        let parse = match *dt {
            DataType::Int32 => quote! {
                #get
                let #v: i32 = match s.parse::<i32>() {
                    Ok(v) => v,
                    Err(_) => {
                        eprintln!("[relops][{}] bad tuple '{}': col {} not i32: '{}'", #rel, tuple, #idx, s);
                        return;
                    }
                };
            },
            DataType::Int64 => quote! {
                #get
                let #v: i64 = match s.parse::<i64>() {
                    Ok(v) => v,
                    Err(_) => {
                        eprintln!("[relops][{}] bad tuple '{}': col {} not i64: '{}'", #rel, tuple, #idx, s);
                        return;
                    }
                };
            },
            DataType::String => quote! {
                #get
                let #v: String = s.to_string();
            },
        };

        stmts.push(parse);
    }

    quote! { #(#stmts)* }
}

/// Parse from `cols: Iterator<Item=&[u8]>` into f0..f{n-1}.
/// This runs inside `filter_map(|line| { ... })`, so errors return None.
fn gen_parse_from_bytes(rel: &str, dts: &[DataType]) -> TokenStream {
    let mut stmts = Vec::<TokenStream>::new();

    for (i, dt) in dts.iter().enumerate() {
        let v = format_ident!("f{i}");
        let idx = i;

        let get_raw = quote! {
            let raw = match cols.next() {
                Some(b) => b,
                None => {
                    eprintln!(
                        "[relops][{}] bad row in {}: '{:?}' (missing col {})",
                        #rel,
                        path.display(),
                        String::from_utf8_lossy(&line),
                        #idx
                    );
                    return None;
                }
            };
        };

        let parse = match *dt {
            DataType::Int32 => quote! {
                #get_raw
                let s = match std::str::from_utf8(raw) {
                    Ok(s) => s.trim(),
                    Err(_) => {
                        eprintln!(
                            "[relops][{}] bad row in {}: '{:?}' (col {} not utf8)",
                            #rel,
                            path.display(),
                            String::from_utf8_lossy(&line),
                            #idx
                        );
                        return None;
                    }
                };
                let #v: i32 = match s.parse::<i32>() {
                    Ok(v) => v,
                    Err(_) => {
                        eprintln!(
                            "[relops][{}] bad row in {}: '{:?}' (col {} not i32: '{}')",
                            #rel,
                            path.display(),
                            String::from_utf8_lossy(&line),
                            #idx,
                            s
                        );
                        return None;
                    }
                };
            },
            DataType::Int64 => quote! {
                #get_raw
                let s = match std::str::from_utf8(raw) {
                    Ok(s) => s.trim(),
                    Err(_) => {
                        eprintln!(
                            "[relops][{}] bad row in {}: '{:?}' (col {} not utf8)",
                            #rel,
                            path.display(),
                            String::from_utf8_lossy(&line),
                            #idx
                        );
                        return None;
                    }
                };
                let #v: i64 = match s.parse::<i64>() {
                    Ok(v) => v,
                    Err(_) => {
                        eprintln!(
                            "[relops][{}] bad row in {}: '{:?}' (col {} not i64: '{}')",
                            #rel,
                            path.display(),
                            String::from_utf8_lossy(&line),
                            #idx,
                            s
                        );
                        return None;
                    }
                };
            },
            DataType::String => quote! {
                #get_raw
                let s = match std::str::from_utf8(raw) {
                    Ok(s) => s.trim(),
                    Err(_) => {
                        eprintln!(
                            "[relops][{}] bad row in {}: '{:?}' (col {} not utf8)",
                            #rel,
                            path.display(),
                            String::from_utf8_lossy(&line),
                            #idx
                        );
                        return None;
                    }
                };
                let #v: String = s.to_string();
            },
        };

        stmts.push(parse);
    }

    quote! { #(#stmts)* }
}
