
.in
.decl Insert_input(a: integer, b: integer, c: integer, d: integer)
.input Insert_input.csv
.decl Remove_input(a: integer, b: integer)
.input Remove_input.csv

.out

# definition of insertion into an ordered list (defines nextElem):
.decl insert(a: integer, b: integer, c: integer, d: integer)
.decl remove(IDCtr: integer, IDN: integer)
.decl hasChild(ParentCtr: integer, ParentN: integer)
.decl assign(IDCtr: integer, IDN: integer, ElemCtr: integer, ElemN: integer, Value: integer)

.decl laterChild(ParentCtr: integer, ParentN: integer, ChildCtr: integer, ChildN: integer)
.decl firstChild(ParentCtr: integer, ParentN: integer, ChildCtr: integer, ChildN: integer)
.decl sibling(ChildCtr1: integer, ChildN1: integer, ChildCtr2: integer, ChildN2: integer)
.decl laterSibling(SibCtr1: integer, SibN1: integer, SibCtr2: integer, SibN2: integer)
.decl laterSibling2(SibCtr1: integer, SibN1: integer, SibCtr3: integer, SibN3: integer)
.decl nextSibling(SibCtr1: integer, SibN1: integer, SibCtr2: integer, SibN2: integer)
.decl hasNextSibling(SibCtr1: integer, SibN1: integer)
.decl nextSiblingAnc(StartCtr: integer, StartN: integer, NextCtr: integer, NextN: integer)
.decl nextElem(PrevCtr: integer, PrevN: integer, NextCtr: integer, NextN: integer)


.decl currentValue(ElemCtr: integer, ElemN: integer, Value: integer)
.decl hasValue(ElemCtr: integer, ElemN: integer)
.decl valueStep(FromCtr: integer, FromN: integer, ToCtr: integer, ToN: integer)
.decl blankStep(FromCtr: integer, FromN: integer, ToCtr: integer, ToN: integer)

.decl value_blank_star(FromCtr: integer, FromN: integer, ToCtr: integer, ToN: integer)
.decl nextVisible(PrevCtr: integer, PrevN: integer, NextCtr: integer, NextN: integer)

.decl result(ctr1: integer, ctr2: integer, value: integer)




.rule
insert(a, b, c, d) :- Insert_input(a, b, c, d).
remove(a, b) :- Remove_input(a, b).
assign(ctr, n, ctr, n, n) :- insert(ctr, n, _, _).
hasChild(ParentCtr, ParentN) :- insert(_, _, ParentCtr, ParentN).

laterChild(ParentCtr, ParentN, Ctr2, N2) :-
  insert(Ctr1, N1, ParentCtr, ParentN),
  insert(Ctr2, N2, ParentCtr, ParentN),
  Ctr1 * 10 + N1 > Ctr2 * 10 + N2.
#  (Ctr1 > Ctr2; (Ctr1 = Ctr2, N1 > N2)). 


firstChild(ParentCtr, ParentN, ChildCtr, ChildN) :-
  insert(ChildCtr, ChildN, ParentCtr, ParentN), 
  !laterChild(ParentCtr, ParentN, ChildCtr, ChildN).


sibling(ChildCtr1, ChildN1, ChildCtr2, ChildN2) :-
  insert(ChildCtr1, ChildN1, ParentCtr, ParentN), 
  insert(ChildCtr2, ChildN2, ParentCtr, ParentN).


laterSibling(Ctr1, N1, Ctr2, N2) :-
  sibling(Ctr1, N1, Ctr2, N2),
  Ctr1 * 10 + N1 > Ctr2 * 10 + N2.
#  (Ctr1 > Ctr2; (Ctr1 = Ctr2, N1 > N2)).


laterSibling2(Ctr1, N1, Ctr3, N3) :-
  sibling(Ctr1, N1, Ctr2, N2),
  sibling(Ctr1, N1, Ctr3, N3),
  Ctr1 * 10 + N1 > Ctr2 * 10 + N2, 
  Ctr2 * 10 + N2 > Ctr3 * 10 + N3.
#  (Ctr1 > Ctr2; (Ctr1 = Ctr2, N1 > N2)),
#  (Ctr2 > Ctr3; (Ctr2 = Ctr3, N2 > N3)).


nextSibling(Ctr1, N1, Ctr2, N2) :-
  laterSibling(Ctr1, N1, Ctr2, N2),
  !laterSibling2(Ctr1, N1, Ctr2, N2).


hasNextSibling(SibCtr1, SibN1) :- laterSibling(SibCtr1, SibN1, _, _).


nextSiblingAnc(StartCtr, StartN, NextCtr, NextN) :- nextSibling(StartCtr, StartN, NextCtr, NextN).
nextSiblingAnc(StartCtr, StartN, NextCtr, NextN) :- 
    !hasNextSibling(StartCtr, StartN), 
    insert(StartCtr, StartN, ParentCtr, ParentN), 
    nextSiblingAnc(ParentCtr, ParentN, NextCtr, NextN).


nextElem(PrevCtr, PrevN, NextCtr, NextN) :- firstChild(PrevCtr, PrevN, NextCtr, NextN).
nextElem(PrevCtr, PrevN, NextCtr, NextN) :- !hasChild(PrevCtr, PrevN), nextSiblingAnc(PrevCtr, PrevN, NextCtr, NextN).



# Assigning values to list elements.
currentValue(ElemCtr, ElemN, Value) :- assign(IDCtr, IDN, ElemCtr, ElemN, Value), !remove(IDCtr, IDN).

hasValue(ElemCtr, ElemN) :- currentValue(ElemCtr, ElemN, _).
valueStep(FromCtr, FromN, ToCtr, ToN) :- hasValue(FromCtr, FromN), nextElem(FromCtr, FromN, ToCtr, ToN). 
blankStep(FromCtr, FromN, ToCtr, ToN) :- 
  !valueStep(FromCtr, FromN, ToCtr, ToN), 
  nextElem(FromCtr, FromN, ToCtr, ToN).

value_blank_star(FromCtr, FromN, ToCtr, ToN) :- valueStep(FromCtr, FromN, ToCtr, ToN).
value_blank_star(FromCtr, FromN, ToCtr, ToN) :- value_blank_star(FromCtr, FromN, ViaCtr, ViaN), blankStep(ViaCtr, ViaN, ToCtr, ToN).

nextVisible(PrevCtr, PrevN, NextCtr, NextN) :- 
  value_blank_star(PrevCtr, PrevN, NextCtr, NextN), 
  hasValue(NextCtr, NextN).

result(ctr1, ctr2, value) :- 
    nextVisible(ctr1, _, ctr2, N2), 
    currentValue(ctr2, N2, value).
